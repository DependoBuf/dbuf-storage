# DBuf Storage

DBuf Storage is a specialized database designed for working with the [DependoBuf protocol](https://github.com/DependoBuf/dependobuf). It provides efficient storage and retrieval for data that follows the DependoBuf schema with dependencies. The primary use case for DBuf Storage is integration with DependoBuf Rust code generation.

## Features

- **Collection-based structure** - Organize your data into logical collections
- **Schema validation** - Define and enforce JSON schemas for both data bodies and dependencies
- **Persistence** - Data is safely stored on disk using the reliable Sled embedded database
- **REST API Server** - Optional HTTP server for accessing your data from any language
- **Performance optimized** - Parallel processing of operations for maximum throughput 
- **Typed & Untyped API** - Work with strongly typed Rust structs or raw JSON

## Usage in Rust

### Installation

Add DBuf Storage to your `Cargo.toml`:

```toml
[dependencies]
dbuf-storage = "0.1.0"
```

### Basic Usage

```rust
let db: Database = Database::new(Some("./dbuf_db"))?;

let collection: Collection = db.create_collection("users")?;

// Body and Dependencies of Message are generated by DBuf Rust codegen
let user1: Message<user::Body, user::Dependencies> = user::User::new(
    user::Body { name: "Alice".to_string(), age: 30 },
    user::Dependencies { x: 42 }
)?;
// store data
let id1: String = collection.insert(&user1)?;

// retrieve data
let retrieved_user: user::User = collection.get(&id1)?;

let updated_user: Message<user::Body, user::Dependencies> = user::User::new(
    user::Body { name: "Bob".to_string(), age: 31 },
    user::Dependencies { x: 100 }
)?;
// update data
collection.update(&id1, &updated_user)?;

// delete data
collection.delete(&id1)?;
```

### Working with Subcollections

Subcollections provide a powerful way to work with data that shares common dependencies:

```rust
let sub_deps: user::Dependencies = user::Dependencies { x: 42 };
let subcollection: dbuf_storage::Subcollection = collection.subcollection(&sub_deps)?;

let body1: user::Body = user::Body { name: "Alice".to_string(), age: 30 };
let id: String = subcollection.insert(&body1)?;

let retrieved_body: user::Body = subcollection.get(&id)?;

let updated_body: user::Body = user::Body { name: "Bob".to_string(), age: 31 };
subcollection.update(&id, &updated_body)?;

let full_message: user::User = collection.get(&id)?;

subcollection.delete(&id)?;
```

### JSON API

For more dynamic usage, you can work directly with JSON:

```rust
// insert data as JSON
let json = r#"{
    "body": { "name": "Charlie", "age": 35 },
    "dependencies": { "department": "Marketing" }
}"#;
let id = collection.insert_json(json.to_string())?;

// retrieve as JSON
let retrieved_json = collection.get_json(&id)?;
```

## REST API Server

DBuf Storage comes with a built-in REST API server for accessing your data from any language.

### Running the Server

```bash
cargo run --bin dbuf-server -- --db-path ./data --bind-address 127.0.0.1:8080
```

### Server Parameters

- `--db-path` or `-d`: Path to the database directory (default: "./data")
- `--bind-address` or `-b`: Address to bind the server (default: "127.0.0.1:8080")

### API Endpoints

#### Collections

- `GET /collections` - List all collections
- `POST /collections` - Create a new collection
- `GET /collections/{name}` - Get collection information
- `POST /collections/schema` - Create a collection with schema

#### Collection Items

- `POST /collections/{name}` - Insert an item
- `GET /collections/{name}/{id}` - Get an item
- `PUT /collections/{name}/{id}` - Update an item
- `DELETE /collections/{name}/{id}` - Delete an item

#### Batch Operations

- `POST /collections/{name}/batch` - Insert multiple items
- `GET /collections/{name}/batch` - Get multiple items
- `DELETE /collections/{name}/batch` - Delete multiple items

#### Subcollections

- `GET /subcollections/{name}/keys` - Get subcollection keys
- `POST /subcollections/{name}` - Insert into subcollection
- `GET /subcollections/{name}/{id}` - Get from subcollection
- `PUT /subcollections/{name}/{id}` - Update in subcollection
- `DELETE /subcollections/{name}/{id}` - Delete from subcollection

## Advanced Features

### Schema Validation

Define JSON schemas for both bodies and dependencies to ensure data integrity:

```rust
let body_schema = r#"{
    "type": "object",
    "properties": {
        "name": { "type": "string" },
        "age": { "type": "integer", "minimum": 0 }
    },
    "required": ["name", "age"],
    "additionalProperties": false
}"#;

let deps_schema = r#"{
    "type": "object",
    "properties": {
        "x": { "type": "integer" }
    },
    "required": ["x"],
    "additionalProperties": false
}"#;

let collection = db.create_collection_with_schema_json(
    "users", 
    body_schema, 
    deps_schema
)?;
```
